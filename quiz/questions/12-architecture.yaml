category: "Architecture Internals"
category_id: 12
source_file: "guide/architecture.md"

questions:
  - id: "12-001"
    difficulty: "intermediate"
    profiles: ["senior", "power"]
    question: "What is the core architecture pattern of Claude Code?"
    options:
      a: "A DAG orchestrator with task planning"
      b: "A simple while(tool_call) loop with no classifier"
      c: "A RAG pipeline with embeddings"
      d: "A multi-agent system with intent router"
    correct: "b"
    explanation: |
      Claude Code runs a remarkably simple `while(tool_call)` loop. There is NO intent classifier, task router, RAG/embedding pipeline, DAG orchestrator, or planner/executor split. The model itself decides when to call tools, which tools to call, and when it's done. This is the "agentic loop" pattern.
    doc_reference:
      file: "guide/architecture.md"
      section: "The Master Loop"
      anchor: "#1-the-master-loop"

  - id: "12-002"
    difficulty: "junior"
    profiles: ["junior", "senior", "power"]
    question: "How many core tools does Claude Code have?"
    options:
      a: "5 tools"
      b: "8 tools"
      c: "12 tools"
      d: "Unlimited (model-dependent)"
    correct: "b"
    explanation: |
      Claude Code has exactly 8 core tools: Bash (universal adapter), Read (file contents), Edit (modify files), Write (create/overwrite), Grep (search contents), Glob (find files), Task (sub-agents), and TodoWrite (progress tracking). That's the entire arsenal.
    doc_reference:
      file: "guide/architecture.md"
      section: "The Tool Arsenal"
      anchor: "#2-the-tool-arsenal"

  - id: "12-003"
    difficulty: "intermediate"
    profiles: ["senior", "power"]
    question: "Which tool is described as Claude's 'swiss-army knife' and 'universal adapter'?"
    options:
      a: "Read"
      b: "Grep"
      c: "Bash"
      d: "Task"
    correct: "c"
    explanation: |
      Bash is Claude's swiss-army knife. It can run any CLI tool (git, npm, docker, curl...), execute scripts, chain commands with pipes, and access system state. The model has been trained on massive amounts of shell data, making it highly effective as a universal adapter.
    doc_reference:
      file: "guide/architecture.md"
      section: "The Bash Universal Adapter"
      anchor: "#the-bash-universal-adapter"

  - id: "12-004"
    difficulty: "intermediate"
    profiles: ["senior", "power"]
    question: "What is the approximate context budget for Claude Code with Claude 3.5 Sonnet?"
    options:
      a: "~32K tokens"
      b: "~100K tokens"
      c: "~200K tokens"
      d: "~500K tokens"
    correct: "c"
    explanation: |
      Claude Code operates within a ~200K token context window. This is shared between: system prompt (~5-15K), CLAUDE.md files (~1-10K), conversation history (variable), tool results (variable), and reserved response buffer (~40-45K). Usable space is approximately 140-150K tokens.
    doc_reference:
      file: "guide/architecture.md"
      section: "Context Budget Breakdown"
      anchor: "#context-budget-breakdown"

  - id: "12-005"
    difficulty: "senior"
    profiles: ["senior", "power"]
    question: "What are the reported auto-compaction thresholds for Claude Code?"
    options:
      a: "50-60%"
      b: "75-92% (conflicting reports)"
      c: "95-99%"
      d: "No auto-compaction exists"
    correct: "b"
    explanation: |
      Auto-compaction thresholds vary by source: PromptLayer analysis reports 92%, community observations report 75-80%. When triggered, older conversation turns are summarized, tool results condensed, and recent context preserved. Use /compact to manually trigger summarization.
    doc_reference:
      file: "guide/architecture.md"
      section: "Auto-Compaction"
      anchor: "#auto-compaction"

  - id: "12-006"
    difficulty: "intermediate"
    profiles: ["junior", "senior", "power"]
    question: "What is the maximum depth for sub-agents spawned via the Task tool?"
    options:
      a: "Unlimited depth"
      b: "Depth = 3"
      c: "Depth = 1 (cannot spawn sub-sub-agents)"
      d: "Depth = 2"
    correct: "c"
    explanation: |
      Sub-agents have a depth=1 limit. They CANNOT spawn sub-sub-agents. This prevents: recursive explosion (infinite resources), context pollution (accumulated context), debugging nightmares (multi-level chains), and unpredictable costs (nested token usage).
    doc_reference:
      file: "guide/architecture.md"
      section: "Why Depth = 1?"
      anchor: "#why-depth--1"

  - id: "12-007"
    difficulty: "senior"
    profiles: ["senior", "power"]
    question: "What does a sub-agent receive when spawned by the Task tool?"
    options:
      a: "Full conversation history + all file reads"
      b: "Task description only (isolated fresh context)"
      c: "Last 10 messages of conversation"
      d: "System prompt + CLAUDE.md files"
    correct: "b"
    explanation: |
      Sub-agents have ISOLATED context. They receive only the task description, have their own fresh context window, access the same tools (except Task), and return only a summary text. This isolation keeps the main context clean and prevents context pollution.
    doc_reference:
      file: "guide/architecture.md"
      section: "Isolation Model"
      anchor: "#isolation-model"

  - id: "12-008"
    difficulty: "intermediate"
    profiles: ["senior", "power"]
    question: "What are the 4 permission layers in Claude Code's security model?"
    options:
      a: "User, Admin, System, Root"
      b: "Interactive prompts, Allow/Deny rules, Hooks, Sandbox"
      c: "Read, Write, Execute, Delete"
      d: "Local, Project, Global, Enterprise"
    correct: "b"
    explanation: |
      Claude Code has 4 layered security: (1) Interactive prompts (allow once/always/deny), (2) Allow/Deny rules in settings.json, (3) Hooks (Pre/Post execution scripts), (4) Sandbox mode (filesystem + network isolation). Each layer adds protection.
    doc_reference:
      file: "guide/architecture.md"
      section: "Permission & Security Model"
      anchor: "#5-permission--security-model"

  - id: "12-009"
    difficulty: "senior"
    profiles: ["senior", "power"]
    question: "What algorithm does the Edit tool use when exact match fails?"
    options:
      a: "Returns error immediately"
      b: "Fuzzy match (whitespace normalization, line ending normalization, context expansion)"
      c: "Regex pattern matching"
      d: "Semantic similarity search"
    correct: "b"
    explanation: |
      When exact match fails, Edit attempts fuzzy matching: (1) Whitespace normalization (trailing spaces, indentation), (2) Line ending normalization (CRLF vs LF), (3) Context expansion (surrounding lines). Only if fuzzy match also fails does it return an error.
    doc_reference:
      file: "guide/architecture.md"
      section: "Fuzzy Matching Details"
      anchor: "#fuzzy-matching-details"

  - id: "12-010"
    difficulty: "intermediate"
    profiles: ["senior", "power"]
    question: "What protocol does MCP (Model Context Protocol) use for communication?"
    options:
      a: "REST API over HTTPS"
      b: "GraphQL"
      c: "JSON-RPC 2.0 over stdio or HTTP"
      d: "gRPC with Protocol Buffers"
    correct: "c"
    explanation: |
      MCP uses JSON-RPC 2.0 over stdio or HTTP transport. MCP tools follow the naming convention `mcp__<server>__<tool>`. Servers start on first use and stay alive during the session. They have the same permission system as native tools.
    doc_reference:
      file: "guide/architecture.md"
      section: "MCP Integration"
      anchor: "#6-mcp-integration"

  - id: "12-011"
    difficulty: "senior"
    profiles: ["power"]
    question: "What is Claude Code's design philosophy, as stated by Anthropic?"
    options:
      a: "More scaffolding, less model - build complex orchestration"
      b: "Less scaffolding, more model - trust Claude's reasoning"
      c: "Maximum control - explicit rules for every case"
      d: "Hybrid approach - RAG + classifier + model"
    correct: "b"
    explanation: |
      Claude Code's philosophy is "Less scaffolding, more model" - trust Claude's reasoning instead of building complex orchestration systems. This means: single model decides (no classifier/router), Grep+Glob (no RAG), simple while loop (no DAG), conversation as state (no state machines).
    doc_reference:
      file: "guide/architecture.md"
      section: "Philosophy: Less Scaffolding, More Model"
      anchor: "#9-philosophy-less-scaffolding-more-model"

  - id: "12-012"
    difficulty: "senior"
    profiles: ["senior", "power"]
    question: "What are the 4 specialized sub-agent types available in Claude Code?"
    options:
      a: "Reader, Writer, Searcher, Executor"
      b: "Explore, Plan, Bash, general-purpose"
      c: "Junior, Senior, Expert, Architect"
      d: "Fast, Balanced, Thorough, Complete"
    correct: "b"
    explanation: |
      Claude Code offers 4 sub-agent types: Explore (codebase exploration, read-only tools), Plan (architecture planning, no Edit/Write), Bash (command execution, Bash only), and general-purpose (complex multi-step tasks, all tools). Each has different tool access.
    doc_reference:
      file: "guide/architecture.md"
      section: "Sub-Agent Types"
      anchor: "#sub-agent-types"
